{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _ from 'lodash';\nimport React, { useState, useCallback, useEffect, useRef } from 'react';\nimport useScrollTo from \"../useScrollTo\";\nimport { Constants } from \"../../helpers\";\nexport var OffsetType;\n\n(function (OffsetType) {\n  OffsetType[\"CENTER\"] = \"CENTER\";\n  OffsetType[\"DYNAMIC\"] = \"DYNAMIC\";\n  OffsetType[\"LEFT\"] = \"LEFT\";\n  OffsetType[\"RIGHT\"] = \"RIGHT\";\n})(OffsetType || (OffsetType = {}));\n\nvar useScrollToItem = function useScrollToItem(props) {\n  var propsScrollViewRef = props.scrollViewRef,\n      itemsCount = props.itemsCount,\n      selectedIndex = props.selectedIndex,\n      _props$offsetType = props.offsetType,\n      offsetType = _props$offsetType === void 0 ? OffsetType.CENTER : _props$offsetType,\n      _props$addOffsetMargi = props.addOffsetMargin,\n      addOffsetMargin = _props$addOffsetMargi === void 0 ? true : _props$addOffsetMargi,\n      _props$outerSpacing = props.outerSpacing,\n      outerSpacing = _props$outerSpacing === void 0 ? 0 : _props$outerSpacing,\n      _props$innerSpacing = props.innerSpacing,\n      innerSpacing = _props$innerSpacing === void 0 ? 0 : _props$innerSpacing;\n  var itemsWidths = useRef(_.times(itemsCount, function () {\n    return null;\n  }));\n  var currentIndex = useRef(selectedIndex || 0);\n\n  var _useState = useState({\n    CENTER: [],\n    LEFT: [],\n    RIGHT: []\n  }),\n      _useState2 = _slicedToArray(_useState, 2),\n      offsets = _useState2[0],\n      setOffsets = _useState2[1];\n\n  var _useScrollTo = useScrollTo({\n    scrollViewRef: propsScrollViewRef\n  }),\n      scrollViewRef = _useScrollTo.scrollViewRef,\n      scrollTo = _useScrollTo.scrollTo,\n      onContentSizeChange = _useScrollTo.onContentSizeChange,\n      onLayout = _useScrollTo.onLayout;\n\n  var setSnapBreakpoints = useCallback(function (itemsWidths) {\n    if (_.isEmpty(itemsWidths)) {\n      return;\n    }\n\n    var screenCenter = Constants.screenWidth / 2;\n    var index = 0;\n    var centeredOffsets = [];\n    var currentCenterOffset = outerSpacing;\n    var leftOffsets = [];\n    leftOffsets.push(outerSpacing - innerSpacing);\n    var rightOffsets = [];\n    rightOffsets.push(-Constants.screenWidth + itemsWidths[0] + outerSpacing + innerSpacing);\n\n    while (index < itemsCount) {\n      centeredOffsets[index] = currentCenterOffset - screenCenter + itemsWidths[index] / 2;\n      ++index;\n      currentCenterOffset += itemsWidths[index - 1] + innerSpacing;\n      leftOffsets[index] = leftOffsets[index - 1] + itemsWidths[index - 1] + innerSpacing;\n      rightOffsets[index] = rightOffsets[index - 1] + itemsWidths[index] + innerSpacing;\n    }\n\n    if (addOffsetMargin) {\n      index = 1;\n\n      while (index < itemsCount - 1) {\n        leftOffsets[index] -= itemsWidths[index - 1];\n        rightOffsets[index] += itemsWidths[index + 1] + innerSpacing;\n        ++index;\n      }\n    }\n\n    setOffsets({\n      CENTER: centeredOffsets,\n      LEFT: leftOffsets,\n      RIGHT: rightOffsets\n    });\n  }, [itemsCount, outerSpacing, innerSpacing, addOffsetMargin]);\n  var onItemLayout = useCallback(function (event, index) {\n    var width = event.nativeEvent.layout.width;\n    itemsWidths.current[index] = width;\n\n    if (!_.includes(itemsWidths.current, null)) {\n      setSnapBreakpoints(itemsWidths.current);\n    }\n  }, [setSnapBreakpoints]);\n  var focusIndex = useCallback(function (index) {\n    var animated = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n    if (index >= 0 && offsets.CENTER.length > index) {\n      if (offsetType !== OffsetType.DYNAMIC) {\n        scrollTo(offsets[offsetType][index], animated);\n      } else {\n        var movingLeft = index < currentIndex.current;\n        currentIndex.current = index;\n        scrollTo(movingLeft ? offsets[OffsetType.RIGHT][index] : offsets[OffsetType.LEFT][index], animated);\n      }\n    }\n  }, [offsets, offsetType, scrollTo]);\n  useEffect(function () {\n    if (!_.isUndefined(selectedIndex)) {\n      focusIndex(selectedIndex);\n    }\n  }, [selectedIndex, focusIndex]);\n  return {\n    scrollViewRef: scrollViewRef,\n    onItemLayout: onItemLayout,\n    itemsWidths: offsets.CENTER.length > 0 ? itemsWidths.current : [],\n    focusIndex: focusIndex,\n    onContentSizeChange: onContentSizeChange,\n    onLayout: onLayout\n  };\n};\n\nuseScrollToItem.offsetType = OffsetType;\nexport default useScrollToItem;","map":{"version":3,"sources":["C:/Users/ruthe/OneDrive/Ãrea de Trabalho/projetos/xmrwallet/node_modules/react-native-ui-lib/src/hooks/useScrollToItem/index.js"],"names":["_","React","useState","useCallback","useEffect","useRef","useScrollTo","Constants","OffsetType","useScrollToItem","props","propsScrollViewRef","scrollViewRef","itemsCount","selectedIndex","offsetType","CENTER","addOffsetMargin","outerSpacing","innerSpacing","itemsWidths","times","currentIndex","LEFT","RIGHT","offsets","setOffsets","scrollTo","onContentSizeChange","onLayout","setSnapBreakpoints","isEmpty","screenCenter","screenWidth","index","centeredOffsets","currentCenterOffset","leftOffsets","push","rightOffsets","onItemLayout","event","width","nativeEvent","layout","current","includes","focusIndex","animated","length","DYNAMIC","movingLeft","isUndefined"],"mappings":"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","sourcesContent":["import _ from 'lodash';\nimport React, { useState, useCallback, useEffect, useRef } from 'react';\nimport useScrollTo from \"../useScrollTo\";\nimport { Constants } from \"../../helpers\";\nexport let OffsetType;\n\n(function (OffsetType) {\n  OffsetType[\"CENTER\"] = \"CENTER\";\n  OffsetType[\"DYNAMIC\"] = \"DYNAMIC\";\n  OffsetType[\"LEFT\"] = \"LEFT\";\n  OffsetType[\"RIGHT\"] = \"RIGHT\";\n})(OffsetType || (OffsetType = {}));\n\nconst useScrollToItem = props => {\n  const {\n    scrollViewRef: propsScrollViewRef,\n    itemsCount,\n    selectedIndex,\n    offsetType = OffsetType.CENTER,\n    addOffsetMargin = true,\n    outerSpacing = 0,\n    innerSpacing = 0\n  } = props;\n  const itemsWidths = useRef(_.times(itemsCount, () => null));\n  const currentIndex = useRef(selectedIndex || 0);\n  const [offsets, setOffsets] = useState({\n    CENTER: [],\n    LEFT: [],\n    RIGHT: []\n  });\n  const {\n    scrollViewRef,\n    scrollTo,\n    onContentSizeChange,\n    onLayout\n  } = useScrollTo({\n    scrollViewRef: propsScrollViewRef\n  }); // TODO: reset?\n  //   useEffect(() => {\n  //     itemsWidths.current = _.times(itemsCount, () => null);\n  //   }, [itemsCount]);\n  // const contentWidth = _.sum(itemsWidths);\n  // TODO: const scrollEnabled = contentWidth.current > containerWidth;\n\n  const setSnapBreakpoints = useCallback(itemsWidths => {\n    if (_.isEmpty(itemsWidths)) {\n      return;\n    }\n\n    const screenCenter = Constants.screenWidth / 2; // TODO: change to something more dynamic?\n\n    let index = 0;\n    const centeredOffsets = [];\n    let currentCenterOffset = outerSpacing;\n    const leftOffsets = [];\n    leftOffsets.push(outerSpacing - innerSpacing);\n    const rightOffsets = [];\n    rightOffsets.push(-Constants.screenWidth + itemsWidths[0] + outerSpacing + innerSpacing);\n\n    while (index < itemsCount) {\n      centeredOffsets[index] = currentCenterOffset - screenCenter + itemsWidths[index] / 2;\n      ++index;\n      currentCenterOffset += itemsWidths[index - 1] + innerSpacing;\n      leftOffsets[index] = leftOffsets[index - 1] + itemsWidths[index - 1] + innerSpacing;\n      rightOffsets[index] = rightOffsets[index - 1] + itemsWidths[index] + innerSpacing;\n    }\n\n    if (addOffsetMargin) {\n      index = 1;\n\n      while (index < itemsCount - 1) {\n        leftOffsets[index] -= itemsWidths[index - 1];\n        rightOffsets[index] += itemsWidths[index + 1] + innerSpacing;\n        ++index;\n      }\n    }\n\n    setOffsets({\n      CENTER: centeredOffsets,\n      LEFT: leftOffsets,\n      RIGHT: rightOffsets\n    }); // default for DYNAMIC is CENTER\n  }, [itemsCount, outerSpacing, innerSpacing, addOffsetMargin]);\n  const onItemLayout = useCallback((event, index) => {\n    const {\n      width\n    } = event.nativeEvent.layout;\n    itemsWidths.current[index] = width;\n\n    if (!_.includes(itemsWidths.current, null)) {\n      setSnapBreakpoints(itemsWidths.current);\n    }\n  }, [setSnapBreakpoints]);\n  const focusIndex = useCallback((index, animated = true) => {\n    if (index >= 0 && offsets.CENTER.length > index) {\n      if (offsetType !== OffsetType.DYNAMIC) {\n        scrollTo(offsets[offsetType][index], animated);\n      } else {\n        const movingLeft = index < currentIndex.current;\n        currentIndex.current = index;\n        scrollTo(movingLeft ? offsets[OffsetType.RIGHT][index] : offsets[OffsetType.LEFT][index], animated);\n      }\n    }\n  }, [offsets, offsetType, scrollTo]);\n  useEffect(() => {\n    if (!_.isUndefined(selectedIndex)) {\n      focusIndex(selectedIndex);\n    }\n  }, [selectedIndex, focusIndex]);\n  return {\n    scrollViewRef,\n    onItemLayout,\n    itemsWidths: offsets.CENTER.length > 0 ? itemsWidths.current : [],\n    focusIndex,\n    onContentSizeChange,\n    onLayout\n  };\n};\n\nuseScrollToItem.offsetType = OffsetType;\nexport default useScrollToItem;"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _ from 'lodash';\n\nfunction assignProperties(a, b) {\n  if (a) {\n    _(b).keys().forEach(function (key) {\n      Object.defineProperty(a, key, Object.getOwnPropertyDescriptor(b, key));\n    });\n  }\n\n  return a;\n}\n\nfunction ensurePath(obj, path) {\n  var pointer = obj;\n  var pathArray = path.split('.');\n  var n = pathArray.length;\n\n  for (var i = 0; i < n; i++) {\n    var segment = pathArray[i];\n\n    if (pointer[segment]) {\n      var descriptor = Object.getOwnPropertyDescriptor(pointer, segment);\n\n      if (descriptor != null && descriptor.get) {\n        Object.defineProperty(pointer, segment, descriptor);\n      }\n    } else {\n      pointer[segment] = pointer[segment] || {};\n    }\n\n    pointer = pointer[segment];\n  }\n\n  return pointer;\n}\n\nexport var Assets = function () {\n  function Assets() {\n    _classCallCheck(this, Assets);\n  }\n\n  _createClass(Assets, [{\n    key: \"loadAssetsGroup\",\n    value: function loadAssetsGroup(groupName, assets) {\n      if (!_.isString(groupName)) {\n        throw new Error('group name should be a string');\n      }\n\n      if (!_.isPlainObject(assets)) {\n        throw new Error('assets should be a hash map or a function (for lazy access)');\n      }\n\n      if (groupName === '') {\n        assignProperties(this, assets);\n      } else {\n        assignProperties(ensurePath(this, groupName), assets);\n      }\n\n      return this;\n    }\n  }]);\n\n  return Assets;\n}();","map":{"version":3,"sources":["C:/Users/ruthe/OneDrive/Ãrea de Trabalho/projetos/xmrwallet/node_modules/react-native-ui-lib/src/assets/Assets.js"],"names":["_","assignProperties","a","b","keys","forEach","key","Object","defineProperty","getOwnPropertyDescriptor","ensurePath","obj","path","pointer","pathArray","split","n","length","i","segment","descriptor","get","Assets","groupName","assets","isString","Error","isPlainObject"],"mappings":";;AAAA,OAAOA,CAAP,MAAc,QAAd;;AAEA,SAASC,gBAAT,CAA0BC,CAA1B,EAA6BC,CAA7B,EAAgC;AAC9B,MAAID,CAAJ,EAAO;AACLF,IAAAA,CAAC,CAACG,CAAD,CAAD,CAAKC,IAAL,GAAYC,OAAZ,CAAoB,UAAAC,GAAG,EAAI;AAEzBC,MAAAA,MAAM,CAACC,cAAP,CAAsBN,CAAtB,EAAyBI,GAAzB,EAA8BC,MAAM,CAACE,wBAAP,CAAgCN,CAAhC,EAAmCG,GAAnC,CAA9B;AACD,KAHD;AAID;;AAED,SAAOJ,CAAP;AACD;;AAED,SAASQ,UAAT,CAAoBC,GAApB,EAAyBC,IAAzB,EAA+B;AAC7B,MAAIC,OAAO,GAAGF,GAAd;AACA,MAAMG,SAAS,GAAGF,IAAI,CAACG,KAAL,CAAW,GAAX,CAAlB;AACA,MAAMC,CAAC,GAAGF,SAAS,CAACG,MAApB;;AAEA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,CAApB,EAAuBE,CAAC,EAAxB,EAA4B;AAC1B,QAAMC,OAAO,GAAGL,SAAS,CAACI,CAAD,CAAzB;;AAEA,QAAIL,OAAO,CAACM,OAAD,CAAX,EAAsB;AACpB,UAAMC,UAAU,GAAGb,MAAM,CAACE,wBAAP,CAAgCI,OAAhC,EAAyCM,OAAzC,CAAnB;;AAEA,UAAIC,UAAJ,YAAIA,UAAU,CAAEC,GAAhB,EAAqB;AACnBd,QAAAA,MAAM,CAACC,cAAP,CAAsBK,OAAtB,EAA+BM,OAA/B,EAAwCC,UAAxC;AACD;AACF,KAND,MAMO;AACLP,MAAAA,OAAO,CAACM,OAAD,CAAP,GAAmBN,OAAO,CAACM,OAAD,CAAP,IAAoB,EAAvC;AACD;;AAEDN,IAAAA,OAAO,GAAGA,OAAO,CAACM,OAAD,CAAjB;AACD;;AAED,SAAON,OAAP;AACD;;AAED,WAAaS,MAAb;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA,WACE,yBAAgBC,SAAhB,EAA2BC,MAA3B,EAAmC;AACjC,UAAI,CAACxB,CAAC,CAACyB,QAAF,CAAWF,SAAX,CAAL,EAA4B;AAC1B,cAAM,IAAIG,KAAJ,CAAU,+BAAV,CAAN;AACD;;AAED,UAAI,CAAC1B,CAAC,CAAC2B,aAAF,CAAgBH,MAAhB,CAAL,EAA8B;AAC5B,cAAM,IAAIE,KAAJ,CAAU,6DAAV,CAAN;AACD;;AAED,UAAIH,SAAS,KAAK,EAAlB,EAAsB;AACpBtB,QAAAA,gBAAgB,CAAC,IAAD,EAAOuB,MAAP,CAAhB;AACD,OAFD,MAEO;AACLvB,QAAAA,gBAAgB,CAACS,UAAU,CAAC,IAAD,EAAOa,SAAP,CAAX,EAA8BC,MAA9B,CAAhB;AACD;;AAED,aAAO,IAAP;AACD;AAjBH;;AAAA;AAAA","sourcesContent":["import _ from 'lodash';\n\nfunction assignProperties(a, b) {\n  if (a) {\n    _(b).keys().forEach(key => {\n      // @ts-ignore\n      Object.defineProperty(a, key, Object.getOwnPropertyDescriptor(b, key));\n    });\n  }\n\n  return a;\n}\n\nfunction ensurePath(obj, path) {\n  let pointer = obj;\n  const pathArray = path.split('.');\n  const n = pathArray.length;\n\n  for (let i = 0; i < n; i++) {\n    const segment = pathArray[i];\n\n    if (pointer[segment]) {\n      const descriptor = Object.getOwnPropertyDescriptor(pointer, segment);\n\n      if (descriptor?.get) {\n        Object.defineProperty(pointer, segment, descriptor);\n      }\n    } else {\n      pointer[segment] = pointer[segment] || {};\n    }\n\n    pointer = pointer[segment];\n  }\n\n  return pointer;\n}\n\nexport class Assets {\n  loadAssetsGroup(groupName, assets) {\n    if (!_.isString(groupName)) {\n      throw new Error('group name should be a string');\n    }\n\n    if (!_.isPlainObject(assets)) {\n      throw new Error('assets should be a hash map or a function (for lazy access)');\n    }\n\n    if (groupName === '') {\n      assignProperties(this, assets);\n    } else {\n      assignProperties(ensurePath(this, groupName), assets);\n    }\n\n    return this;\n  }\n\n}"]},"metadata":{},"sourceType":"module"}
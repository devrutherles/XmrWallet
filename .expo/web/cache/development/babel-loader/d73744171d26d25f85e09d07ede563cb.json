{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nimport _ from 'lodash';\nimport PropTypes from 'prop-types';\nimport React from 'react';\nimport { ViewPropTypes } from \"react-native-web/dist/index\";\nimport StyleSheet from \"react-native-web/dist/exports/StyleSheet\";\nimport Animated from \"react-native-web/dist/exports/Animated\";\nimport { Colors } from \"../../style\";\nimport { BaseComponent } from \"../../commons\";\nimport View from \"../../components/view\";\n\nvar AnimatedScanner = function (_BaseComponent) {\n  _inherits(AnimatedScanner, _BaseComponent);\n\n  var _super = _createSuper(AnimatedScanner);\n\n  function AnimatedScanner(props) {\n    var _this;\n\n    _classCallCheck(this, AnimatedScanner);\n\n    _this = _super.call(this, props);\n    _this.state = {\n      animatedProgress: new Animated.Value(0),\n      isDone: false\n    };\n    return _this;\n  }\n\n  _createClass(AnimatedScanner, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      var _this$props = this.props,\n          progress = _this$props.progress,\n          duration = _this$props.duration;\n\n      if (progress > 0) {\n        this.animate(progress, duration);\n      }\n    }\n  }, {\n    key: \"generateStyles\",\n    value: function generateStyles() {\n      this.styles = createStyles(this.props);\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps) {\n      var _this$props2 = this.props,\n          progress = _this$props2.progress,\n          duration = _this$props2.duration;\n\n      if (prevProps.progress !== progress) {\n        this.animate(progress, duration);\n      }\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      this.state.animatedProgress.stopAnimation();\n    }\n  }, {\n    key: \"animate\",\n    value: function animate(toValue, duration) {\n      var _this2 = this;\n\n      var animatedProgress = this.state.animatedProgress;\n      Animated.timing(animatedProgress, {\n        toValue: toValue,\n        duration: duration,\n        useNativeDriver: false\n      }).start(function (_ref) {\n        var finished = _ref.finished;\n\n        if (finished) {\n          var isDone = toValue >= 100;\n\n          _this2.setState({\n            isDone: isDone\n          });\n\n          _.invoke(_this2.props, 'onBreakpoint', {\n            progress: toValue,\n            isDone: isDone\n          });\n        }\n      });\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this$props3 = this.props,\n          opacity = _this$props3.opacity,\n          backgroundColor = _this$props3.backgroundColor,\n          hideScannerLine = _this$props3.hideScannerLine,\n          style = _this$props3.style,\n          containerStyle = _this$props3.containerStyle;\n      var _this$state = this.state,\n          isDone = _this$state.isDone,\n          animatedProgress = _this$state.animatedProgress;\n      return React.createElement(View, {\n        style: [_objectSpread({}, StyleSheet.absoluteFillObject), containerStyle]\n      }, React.createElement(Animated.View, {\n        style: [this.styles.container, style, opacity && {\n          opacity: opacity\n        }, backgroundColor && {\n          backgroundColor: backgroundColor\n        }, {\n          left: animatedProgress.interpolate({\n            inputRange: [0, 100],\n            outputRange: ['0%', '100%']\n          })\n        }]\n      }, isDone && !hideScannerLine && React.createElement(View, {\n        style: this.styles.scanner\n      })));\n    }\n  }]);\n\n  return AnimatedScanner;\n}(BaseComponent);\n\nAnimatedScanner.displayName = 'AnimatedScanner';\nAnimatedScanner.propTypes = {\n  progress: PropTypes.number,\n  duration: PropTypes.number,\n  opacity: PropTypes.number,\n  backgroundColor: PropTypes.string,\n  onBreakpoint: PropTypes.func,\n  hideScannerLine: PropTypes.bool,\n  containerStyle: ViewPropTypes.style\n};\nAnimatedScanner.defaultProps = {\n  progress: 0,\n  duration: 1000\n};\nexport { AnimatedScanner as default };\n\nfunction createStyles() {\n  return StyleSheet.create({\n    container: _objectSpread(_objectSpread({}, StyleSheet.absoluteFillObject), {}, {\n      backgroundColor: Colors.white,\n      opacity: 0.9\n    }),\n    scanner: _objectSpread(_objectSpread({}, StyleSheet.absoluteFillObject), {}, {\n      borderWidth: StyleSheet.hairlineWidth,\n      borderColor: Colors.grey50\n    })\n  });\n}","map":{"version":3,"sources":["C:/Users/ruthe/OneDrive/Ãrea de Trabalho/projetos/xmrwallet/node_modules/react-native-ui-lib/src/components/animatedScanner/index.js"],"names":["_","PropTypes","React","ViewPropTypes","Colors","BaseComponent","View","AnimatedScanner","props","state","animatedProgress","Animated","Value","isDone","progress","duration","animate","styles","createStyles","prevProps","stopAnimation","toValue","timing","useNativeDriver","start","finished","setState","invoke","opacity","backgroundColor","hideScannerLine","style","containerStyle","StyleSheet","absoluteFillObject","container","left","interpolate","inputRange","outputRange","scanner","displayName","propTypes","number","string","onBreakpoint","func","bool","defaultProps","create","white","borderWidth","hairlineWidth","borderColor","grey50"],"mappings":"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","sourcesContent":["import _ from 'lodash';\nimport PropTypes from 'prop-types';\nimport React from 'react';\nimport {ViewPropTypes, StyleSheet, Animated} from 'react-native';\nimport {Colors} from '../../style';\nimport {BaseComponent} from '../../commons';\nimport View from '../../components/view';\n\n\n// TODO: add finisher animation (check icon animation or something)\n/**\n * @description: Scanner component for progress indication\n * @extends: Animated.View\n * @gif: https://media.giphy.com/media/l49JVcxoclUXbryiA/giphy.gif\n * @example: https://github.com/wix/react-native-ui-lib/blob/master/demo/src/screens/componentScreens/CardScannerScreen.js\n */\nexport default class AnimatedScanner extends BaseComponent {\n  static displayName = 'AnimatedScanner';\n  static propTypes = {\n    /**\n     * animated value between 0 and 100\n     */\n    // progress: PropTypes.object,\n    progress: PropTypes.number,\n    /**\n     * Duration of current break (can be change between breaks)\n     */\n    duration: PropTypes.number,\n    /**\n     * scanner opacity\n     */\n    opacity: PropTypes.number,\n    /**\n     * scanner background color\n     */\n    backgroundColor: PropTypes.string,\n    /**\n     * breakpoint callback - ({progress, isDone}) => {}\n     */\n    onBreakpoint: PropTypes.func,\n    /**\n     * should hide the scanner line\n     */\n    hideScannerLine: PropTypes.bool,\n    /**\n     * the container style\n     */\n    containerStyle: ViewPropTypes.style\n  };\n\n  static defaultProps = {\n    progress: 0,\n    duration: 1000\n  };\n\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      animatedProgress: new Animated.Value(0),\n      isDone: false\n    };\n  }\n\n  componentDidMount() {\n    const {progress, duration} = this.props;\n\n    if (progress > 0) {\n      this.animate(progress, duration);\n    }\n  }\n\n  generateStyles() {\n    this.styles = createStyles(this.props);\n  }\n\n  componentDidUpdate(prevProps) {\n    const {progress, duration} = this.props;\n\n    if (prevProps.progress !== progress) {\n      this.animate(progress, duration);\n    }\n  }\n\n  componentWillUnmount() {\n    this.state.animatedProgress.stopAnimation();\n  }\n\n  animate(toValue, duration) {\n    const {animatedProgress} = this.state;\n\n    Animated.timing(animatedProgress, {\n      toValue,\n      duration,\n      useNativeDriver: false\n    }).start(({finished}) => {\n      if (finished) {\n        const isDone = toValue >= 100;\n        this.setState({isDone});\n        _.invoke(this.props, 'onBreakpoint', {progress: toValue, isDone});\n      }\n    });\n  }\n\n  render() {\n    const {opacity, backgroundColor, hideScannerLine, style, containerStyle} = this.props;\n    const {isDone, animatedProgress} = this.state;\n\n    return (\n      <View style={[{...StyleSheet.absoluteFillObject}, containerStyle]}>\n        <Animated.View\n          style={[\n            this.styles.container,\n            style,\n            opacity && {opacity},\n            backgroundColor && {backgroundColor},\n            {\n              left: animatedProgress.interpolate({\n                inputRange: [0, 100],\n                outputRange: ['0%', '100%']\n              })\n            }\n          ]}\n        >\n          {isDone && !hideScannerLine && <View style={this.styles.scanner}/>}\n        </Animated.View>\n      </View>\n    );\n  }\n}\n\nfunction createStyles() {\n  return StyleSheet.create({\n    container: {\n      ...StyleSheet.absoluteFillObject,\n      backgroundColor: Colors.white,\n      opacity: 0.9\n    },\n    scanner: {\n      ...StyleSheet.absoluteFillObject,\n      borderWidth: StyleSheet.hairlineWidth,\n      borderColor: Colors.grey50\n    }\n  });\n}\n"]},"metadata":{},"sourceType":"module"}
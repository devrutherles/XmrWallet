{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nimport _pt from \"prop-types\";\nimport _ from 'lodash';\nimport React, { PureComponent } from 'react';\nimport Animated from \"react-native-web/dist/exports/Animated\";\nimport { Constants } from \"../../helpers\";\nimport asPanViewConsumer from \"./asPanViewConsumer\";\nimport PanningProvider from \"./panningProvider\";\nvar DEFAULT_DIRECTIONS = [PanningProvider.Directions.UP, PanningProvider.Directions.DOWN, PanningProvider.Directions.LEFT, PanningProvider.Directions.RIGHT];\nvar DEFAULT_SPEED = 20;\nvar DEFAULT_BOUNCINESS = 6;\nvar DEFAULT_DISMISS_ANIMATION_DURATION = 280;\nvar DEFAULT_ANIMATION_OPTIONS = {\n  speed: DEFAULT_SPEED,\n  bounciness: DEFAULT_BOUNCINESS,\n  duration: DEFAULT_DISMISS_ANIMATION_DURATION\n};\nvar MAXIMUM_DRAGS_AFTER_SWIPE = 2;\n\nvar PanDismissibleView = function (_PureComponent) {\n  _inherits(PanDismissibleView, _PureComponent);\n\n  var _super = _createSuper(PanDismissibleView);\n\n  function PanDismissibleView(props) {\n    var _this;\n\n    _classCallCheck(this, PanDismissibleView);\n\n    _this = _super.call(this, props);\n    _this.shouldDismissAfterReset = false;\n    _this.ref = React.createRef();\n    _this.animTranslateX = new Animated.Value(0);\n    _this.animTranslateY = new Animated.Value(0);\n    _this.left = 0;\n    _this.top = 0;\n    _this.width = 0;\n    _this.height = 0;\n    _this.thresholdX = 0;\n    _this.thresholdY = 0;\n    _this.swipe = {};\n    _this.counter = 0;\n\n    _this.onLayout = function (event) {\n      if (_this.height === 0) {\n        var layout = event.nativeEvent.layout;\n        var threshold = _this.props.threshold;\n        _this.height = layout.height;\n        _this.thresholdY = _.get(threshold, 'y', layout.height / 2);\n        _this.width = layout.width;\n        _this.thresholdX = _.get(threshold, 'x', layout.width / 2);\n\n        _this.initPositions();\n      }\n    };\n\n    _this.initPositions = function (extraDataForSetState, runAfterSetState) {\n      _this.setNativeProps(0, 0);\n\n      _this.animTranslateX = new Animated.Value(0);\n      _this.animTranslateY = new Animated.Value(0);\n\n      _this.setState(_objectSpread({}, extraDataForSetState), runAfterSetState);\n    };\n\n    _this.onPanStart = function () {\n      _this.swipe = {};\n      _this.counter = 0;\n    };\n\n    _this.onDrag = function (deltas) {\n      var left = deltas.x ? Math.round(deltas.x) : 0;\n      var top = deltas.y ? Math.round(deltas.y) : 0;\n\n      _this.setNativeProps(left, top);\n\n      if (_this.swipe.x || _this.swipe.y) {\n        if (_this.counter < MAXIMUM_DRAGS_AFTER_SWIPE) {\n          _this.counter += 1;\n        } else {\n          _this.swipe = {};\n        }\n      }\n    };\n\n    _this.setNativeProps = function (left, top) {\n      if (_this.ref.current) {\n        _this.ref.current.setNativeProps({\n          style: {\n            left: left,\n            top: top\n          }\n        });\n\n        _this.left = left;\n        _this.top = top;\n      }\n    };\n\n    _this.onSwipe = function (swipeDirections) {\n      _this.swipe = swipeDirections;\n    };\n\n    _this.onPanEnd = function () {\n      var _this$props$direction = _this.props.directions,\n          directions = _this$props$direction === void 0 ? DEFAULT_DIRECTIONS : _this$props$direction;\n\n      if (_this.swipe.x || _this.swipe.y) {\n        var _this$getDismissAnima = _this.getDismissAnimationDirection(),\n            isRight = _this$getDismissAnima.isRight,\n            isDown = _this$getDismissAnima.isDown;\n\n        _this._animateDismiss(isRight, isDown);\n      } else {\n        var endValue = {\n          x: Math.round(_this.left),\n          y: Math.round(_this.top)\n        };\n\n        if (directions.includes(PanningProvider.Directions.LEFT) && endValue.x <= -_this.thresholdX || directions.includes(PanningProvider.Directions.RIGHT) && endValue.x >= _this.thresholdX || directions.includes(PanningProvider.Directions.UP) && endValue.y <= -_this.thresholdY || directions.includes(PanningProvider.Directions.DOWN) && endValue.y >= _this.thresholdY) {\n          var _this$getDismissAnima2 = _this.getDismissAnimationDirection(),\n              _isRight = _this$getDismissAnima2.isRight,\n              _isDown = _this$getDismissAnima2.isDown;\n\n          _this._animateDismiss(_isRight, _isDown);\n        } else {\n          _this.resetPosition();\n        }\n      }\n    };\n\n    _this.resetPosition = function () {\n      var animationOptions = _this.props.animationOptions;\n\n      var _ref = animationOptions || DEFAULT_ANIMATION_OPTIONS,\n          speed = _ref.speed,\n          bounciness = _ref.bounciness;\n\n      var toX = -_this.left;\n      var toY = -_this.top;\n      var animations = [];\n\n      if (!_.isUndefined(toX)) {\n        animations.push(Animated.spring(_this.animTranslateX, {\n          toValue: Math.round(toX),\n          useNativeDriver: true,\n          speed: speed,\n          bounciness: bounciness\n        }));\n      }\n\n      if (!_.isUndefined(toY)) {\n        animations.push(Animated.spring(_this.animTranslateY, {\n          toValue: Math.round(toY),\n          useNativeDriver: true,\n          speed: speed,\n          bounciness: bounciness\n        }));\n      }\n\n      _this.setState({\n        isAnimating: true\n      }, function () {\n        Animated.parallel(animations).start(_this.onResetPositionFinished);\n      });\n    };\n\n    _this.onResetPositionFinished = function () {\n      var runAfterSetState = _this.shouldDismissAfterReset ? _this.animateDismiss : undefined;\n      _this.shouldDismissAfterReset = false;\n\n      _this.initPositions({\n        isAnimating: false\n      }, runAfterSetState);\n    };\n\n    _this.getDismissAnimationDirection = function () {\n      var allowDiagonalDismiss = _this.props.allowDiagonalDismiss;\n      var _this$props$context = _this.props.context,\n          swipeDirections = _this$props$context.swipeDirections,\n          swipeVelocities = _this$props$context.swipeVelocities,\n          dragDirections = _this$props$context.dragDirections,\n          dragDeltas = _this$props$context.dragDeltas;\n      var hasHorizontalSwipe = !_.isUndefined(swipeDirections.x);\n      var hasVerticalSwipe = !_.isUndefined(swipeDirections.y);\n      var isRight;\n      var isDown;\n\n      if (hasHorizontalSwipe || hasVerticalSwipe) {\n        if (!allowDiagonalDismiss && hasHorizontalSwipe && hasVerticalSwipe) {\n          if (Math.abs(swipeVelocities.y) > Math.abs(swipeVelocities.x)) {\n            isDown = swipeDirections.y === PanningProvider.Directions.DOWN;\n          } else {\n            isRight = swipeDirections.x === PanningProvider.Directions.RIGHT;\n          }\n\n          return {\n            isRight: isRight,\n            isDown: isDown\n          };\n        }\n\n        if (hasHorizontalSwipe) {\n          isRight = swipeDirections.x === PanningProvider.Directions.RIGHT;\n        }\n\n        if (hasVerticalSwipe) {\n          isDown = swipeDirections.y === PanningProvider.Directions.DOWN;\n        }\n      } else {\n        var hasHorizontalDrag = !_.isUndefined(dragDirections.x);\n        var hasVerticalDrag = !_.isUndefined(dragDirections.y);\n\n        if (!allowDiagonalDismiss && hasHorizontalDrag && hasVerticalDrag) {\n          if (Math.abs(dragDeltas.y) > Math.abs(dragDeltas.x)) {\n            isDown = dragDirections.y === PanningProvider.Directions.DOWN;\n          } else {\n            isRight = dragDirections.x === PanningProvider.Directions.RIGHT;\n          }\n\n          return {\n            isRight: isRight,\n            isDown: isDown\n          };\n        }\n\n        if (hasHorizontalDrag) {\n          isRight = dragDirections.x === PanningProvider.Directions.RIGHT;\n        }\n\n        if (hasVerticalDrag) {\n          isDown = dragDirections.y === PanningProvider.Directions.DOWN;\n        }\n      }\n\n      return {\n        isRight: isRight,\n        isDown: isDown\n      };\n    };\n\n    _this.animateDismiss = function () {\n      var isAnimating = _this.state.isAnimating;\n\n      if (isAnimating) {\n        _this.shouldDismissAfterReset = true;\n      } else {\n        var _this$props$direction2 = _this.props.directions,\n            directions = _this$props$direction2 === void 0 ? [] : _this$props$direction2;\n        var hasUp = directions.includes(PanningProvider.Directions.UP);\n        var hasRight = directions.includes(PanningProvider.Directions.RIGHT);\n        var hasLeft = directions.includes(PanningProvider.Directions.LEFT);\n        var hasDown = !hasUp && !hasLeft && !hasRight;\n        var verticalDismiss = hasDown ? true : hasUp ? false : undefined;\n        var horizontalDismiss = hasRight ? true : hasLeft ? false : undefined;\n\n        _this._animateDismiss(horizontalDismiss, verticalDismiss);\n      }\n    };\n\n    _this._animateDismiss = function (isRight, isDown) {\n      var animationOptions = _this.props.animationOptions;\n\n      var _ref2 = animationOptions || DEFAULT_ANIMATION_OPTIONS,\n          duration = _ref2.duration;\n\n      var animations = [];\n      var toX;\n      var toY;\n\n      if (!_.isUndefined(isRight)) {\n        var maxSize = Constants.screenWidth + _this.width;\n        toX = isRight ? maxSize : -maxSize;\n      }\n\n      if (!_.isUndefined(isDown)) {\n        var _maxSize = Constants.screenHeight + _this.height;\n\n        toY = isDown ? _maxSize : -_maxSize;\n      }\n\n      if (!_.isUndefined(toX)) {\n        animations.push(Animated.timing(_this.animTranslateX, {\n          toValue: Math.round(toX),\n          useNativeDriver: true,\n          duration: duration\n        }));\n      }\n\n      if (!_.isUndefined(toY)) {\n        animations.push(Animated.timing(_this.animTranslateY, {\n          toValue: Math.round(toY),\n          useNativeDriver: true,\n          duration: duration\n        }));\n      }\n\n      _this.setState({\n        isAnimating: true\n      }, function () {\n        Animated.parallel(animations).start(_this.onDismissAnimationFinished);\n      });\n    };\n\n    _this.onDismissAnimationFinished = function (_ref3) {\n      var finished = _ref3.finished;\n\n      if (finished) {\n        _this.props.onDismiss == null ? void 0 : _this.props.onDismiss();\n      }\n    };\n\n    _this.state = {\n      isAnimating: false\n    };\n    return _this;\n  }\n\n  _createClass(PanDismissibleView, [{\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps) {\n      var isAnimating = this.state.isAnimating;\n      var _this$props$context2 = this.props.context,\n          isPanning = _this$props$context2.isPanning,\n          dragDeltas = _this$props$context2.dragDeltas,\n          swipeDirections = _this$props$context2.swipeDirections;\n      var _prevProps$context = prevProps.context,\n          prevIsPanning = _prevProps$context.isPanning,\n          prevDragDeltas = _prevProps$context.dragDeltas,\n          prevSwipeDirections = _prevProps$context.swipeDirections;\n\n      if (isPanning !== prevIsPanning) {\n        if (isPanning && !isAnimating) {\n          this.onPanStart();\n        } else {\n          this.onPanEnd();\n        }\n      }\n\n      if (isPanning && (dragDeltas.x || dragDeltas.y) && (dragDeltas.x !== prevDragDeltas.x || dragDeltas.y !== prevDragDeltas.y)) {\n        this.onDrag(dragDeltas);\n      }\n\n      if (isPanning && (swipeDirections.x || swipeDirections.y) && (swipeDirections.x !== prevSwipeDirections.x || swipeDirections.y !== prevSwipeDirections.y)) {\n        this.onSwipe(swipeDirections);\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var style = this.props.style;\n      var isAnimating = this.state.isAnimating;\n      var transform = isAnimating ? [{\n        translateX: this.animTranslateX\n      }, {\n        translateY: this.animTranslateY\n      }] : [];\n      return React.createElement(Animated.View, {\n        ref: this.ref,\n        style: [style, {\n          transform: transform\n        }],\n        onLayout: this.onLayout\n      }, this.props.children);\n    }\n  }]);\n\n  return PanDismissibleView;\n}(PureComponent);\n\nPanDismissibleView.propTypes = {\n  directions: _pt.array,\n  onDismiss: _pt.func,\n  animationOptions: _pt.shape({\n    speed: _pt.number,\n    bounciness: _pt.number,\n    duration: _pt.number\n  }),\n  allowDiagonalDismiss: _pt.bool,\n  context: _pt.shape({\n    isPanning: _pt.bool.isRequired\n  }).isRequired\n};\nPanDismissibleView.displayName = 'PanDismissibleView';\nPanDismissibleView.defaultProps = {\n  directions: DEFAULT_DIRECTIONS,\n  animationOptions: DEFAULT_ANIMATION_OPTIONS,\n  onDismiss: _.noop,\n  allowDiagonalDismiss: false\n};\nexport default asPanViewConsumer(PanDismissibleView);","map":{"version":3,"sources":["C:/Users/ruthe/OneDrive/Ãrea de Trabalho/projetos/xmrwallet/node_modules/react-native-ui-lib/src/components/panningViews/panDismissibleView.js"],"names":["_pt","_","React","PureComponent","Constants","asPanViewConsumer","PanningProvider","DEFAULT_DIRECTIONS","Directions","UP","DOWN","LEFT","RIGHT","DEFAULT_SPEED","DEFAULT_BOUNCINESS","DEFAULT_DISMISS_ANIMATION_DURATION","DEFAULT_ANIMATION_OPTIONS","speed","bounciness","duration","MAXIMUM_DRAGS_AFTER_SWIPE","PanDismissibleView","props","shouldDismissAfterReset","ref","createRef","animTranslateX","Animated","Value","animTranslateY","left","top","width","height","thresholdX","thresholdY","swipe","counter","onLayout","event","layout","nativeEvent","threshold","get","initPositions","extraDataForSetState","runAfterSetState","setNativeProps","setState","onPanStart","onDrag","deltas","x","Math","round","y","current","style","onSwipe","swipeDirections","onPanEnd","directions","getDismissAnimationDirection","isRight","isDown","_animateDismiss","endValue","includes","resetPosition","animationOptions","toX","toY","animations","isUndefined","push","spring","toValue","useNativeDriver","isAnimating","parallel","start","onResetPositionFinished","animateDismiss","undefined","allowDiagonalDismiss","context","swipeVelocities","dragDirections","dragDeltas","hasHorizontalSwipe","hasVerticalSwipe","abs","hasHorizontalDrag","hasVerticalDrag","state","hasUp","hasRight","hasLeft","hasDown","verticalDismiss","horizontalDismiss","maxSize","screenWidth","screenHeight","timing","onDismissAnimationFinished","finished","onDismiss","prevProps","isPanning","prevIsPanning","prevDragDeltas","prevSwipeDirections","transform","translateX","translateY","children","propTypes","array","func","shape","number","bool","isRequired","displayName","defaultProps","noop"],"mappings":"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","sourcesContent":["import _pt from \"prop-types\";\nimport _ from 'lodash';\nimport React, { PureComponent } from 'react';\nimport { Animated } from 'react-native';\nimport { Constants } from \"../../helpers\";\nimport asPanViewConsumer from \"./asPanViewConsumer\";\nimport PanningProvider from \"./panningProvider\";\nconst DEFAULT_DIRECTIONS = [PanningProvider.Directions.UP, PanningProvider.Directions.DOWN, PanningProvider.Directions.LEFT, PanningProvider.Directions.RIGHT];\nconst DEFAULT_SPEED = 20;\nconst DEFAULT_BOUNCINESS = 6;\nconst DEFAULT_DISMISS_ANIMATION_DURATION = 280;\nconst DEFAULT_ANIMATION_OPTIONS = {\n  speed: DEFAULT_SPEED,\n  bounciness: DEFAULT_BOUNCINESS,\n  duration: DEFAULT_DISMISS_ANIMATION_DURATION\n};\nconst MAXIMUM_DRAGS_AFTER_SWIPE = 2;\n\n/**\n * @description: PanDismissibleView component created to making listening to swipe and drag events easier,\n * @notes: Has to be used as a child of a PanningProvider that also has a PanListenerView.\n *         The PanListenerView is the one that sends the drag\\swipe events.\n * @gif: https://github.com/wix/react-native-ui-lib/blob/master/demo/showcase/PanDismissibleView/PanDismissibleView.gif?raw=true\n */\nclass PanDismissibleView extends PureComponent {\n  static propTypes = {\n    /**\n       * The directions of the allowed pan (default allows all directions)\n       * Types: UP, DOWN, LEFT and RIGHT (using PanningProvider.Directions.###)\n       */\n    directions: _pt.array,\n\n    /**\n       * onDismiss callback\n       */\n    onDismiss: _pt.func,\n\n    /**\n       * Some animation options to choose from, defaults are set for:\n       * speed - the animation speed (default is 20)\n       * bounciness - the animation bounciness (default is 6)\n       * duration - the dismiss animation duration (default is 280)\n       */\n    animationOptions: _pt.shape({\n      /**\n         * The return animation speed (default is 20)\n         */\n      speed: _pt.number,\n\n      /**\n         * The return animation bounciness (default is 6)\n         */\n      bounciness: _pt.number,\n\n      /**\n         * The dismiss animation duration (default is 280)\n         */\n      duration: _pt.number\n    }),\n\n    /**\n       * Allow diagonal dismiss, this is false by default,\n       * since it looks better and most cases.\n       */\n    allowDiagonalDismiss: _pt.bool,\n    context: _pt.shape({\n      isPanning: _pt.bool.isRequired\n    }).isRequired\n  };\n  static displayName = 'PanDismissibleView';\n  static defaultProps = {\n    directions: DEFAULT_DIRECTIONS,\n    animationOptions: DEFAULT_ANIMATION_OPTIONS,\n    onDismiss: _.noop,\n    allowDiagonalDismiss: false\n  };\n  shouldDismissAfterReset = false;\n  ref = React.createRef();\n  animTranslateX = new Animated.Value(0);\n  animTranslateY = new Animated.Value(0);\n  left = 0;\n  top = 0;\n  width = 0;\n  height = 0;\n  thresholdX = 0;\n  thresholdY = 0;\n  swipe = {};\n  counter = 0;\n\n  constructor(props) {\n    super(props);\n    this.state = {\n      isAnimating: false\n    };\n  }\n\n  componentDidUpdate(prevProps) {\n    const {\n      isAnimating\n    } = this.state;\n    const {\n      isPanning,\n      dragDeltas,\n      swipeDirections\n    } = this.props.context;\n    const {\n      isPanning: prevIsPanning,\n      dragDeltas: prevDragDeltas,\n      swipeDirections: prevSwipeDirections\n    } = prevProps.context;\n\n    if (isPanning !== prevIsPanning) {\n      if (isPanning && !isAnimating) {\n        // do not start a new pan if we're still animating\n        this.onPanStart();\n      } else {\n        this.onPanEnd();\n      }\n    }\n\n    if (isPanning && (dragDeltas.x || dragDeltas.y) && (dragDeltas.x !== prevDragDeltas.x || dragDeltas.y !== prevDragDeltas.y)) {\n      this.onDrag(dragDeltas);\n    }\n\n    if (isPanning && (swipeDirections.x || swipeDirections.y) && (swipeDirections.x !== prevSwipeDirections.x || swipeDirections.y !== prevSwipeDirections.y)) {\n      this.onSwipe(swipeDirections);\n    }\n  }\n\n  onLayout = event => {\n    if (this.height === 0) {\n      const layout = event.nativeEvent.layout;\n      const {\n        threshold\n      } = this.props;\n      this.height = layout.height;\n      this.thresholdY = _.get(threshold, 'y', layout.height / 2);\n      this.width = layout.width;\n      this.thresholdX = _.get(threshold, 'x', layout.width / 2);\n      this.initPositions();\n    }\n  };\n  initPositions = (extraDataForSetState, runAfterSetState) => {\n    this.setNativeProps(0, 0);\n    this.animTranslateX = new Animated.Value(0);\n    this.animTranslateY = new Animated.Value(0);\n    this.setState({ ...extraDataForSetState\n    }, runAfterSetState);\n  };\n  onPanStart = () => {\n    this.swipe = {};\n    this.counter = 0;\n  };\n  onDrag = deltas => {\n    const left = deltas.x ? Math.round(deltas.x) : 0;\n    const top = deltas.y ? Math.round(deltas.y) : 0;\n    this.setNativeProps(left, top);\n\n    if (this.swipe.x || this.swipe.y) {\n      if (this.counter < MAXIMUM_DRAGS_AFTER_SWIPE) {\n        this.counter += 1;\n      } else {\n        this.swipe = {};\n      }\n    }\n  };\n  setNativeProps = (left, top) => {\n    if (this.ref.current) {\n      this.ref.current.setNativeProps({\n        style: {\n          left,\n          top\n        }\n      });\n      this.left = left;\n      this.top = top;\n    }\n  };\n  onSwipe = swipeDirections => {\n    this.swipe = swipeDirections;\n  };\n  onPanEnd = () => {\n    const {\n      directions = DEFAULT_DIRECTIONS\n    } = this.props;\n\n    if (this.swipe.x || this.swipe.y) {\n      const {\n        isRight,\n        isDown\n      } = this.getDismissAnimationDirection();\n\n      this._animateDismiss(isRight, isDown);\n    } else {\n      const endValue = {\n        x: Math.round(this.left),\n        y: Math.round(this.top)\n      };\n\n      if (directions.includes(PanningProvider.Directions.LEFT) && endValue.x <= -this.thresholdX || directions.includes(PanningProvider.Directions.RIGHT) && endValue.x >= this.thresholdX || directions.includes(PanningProvider.Directions.UP) && endValue.y <= -this.thresholdY || directions.includes(PanningProvider.Directions.DOWN) && endValue.y >= this.thresholdY) {\n        const {\n          isRight,\n          isDown\n        } = this.getDismissAnimationDirection();\n\n        this._animateDismiss(isRight, isDown);\n      } else {\n        this.resetPosition();\n      }\n    }\n  };\n  resetPosition = () => {\n    const {\n      animationOptions\n    } = this.props;\n    const {\n      speed,\n      bounciness\n    } = animationOptions || DEFAULT_ANIMATION_OPTIONS;\n    const toX = -this.left;\n    const toY = -this.top;\n    const animations = [];\n\n    if (!_.isUndefined(toX)) {\n      animations.push(Animated.spring(this.animTranslateX, {\n        toValue: Math.round(toX),\n        useNativeDriver: true,\n        speed,\n        bounciness\n      }));\n    }\n\n    if (!_.isUndefined(toY)) {\n      animations.push(Animated.spring(this.animTranslateY, {\n        toValue: Math.round(toY),\n        useNativeDriver: true,\n        speed,\n        bounciness\n      }));\n    }\n\n    this.setState({\n      isAnimating: true\n    }, () => {\n      Animated.parallel(animations).start(this.onResetPositionFinished);\n    });\n  };\n  onResetPositionFinished = () => {\n    const runAfterSetState = this.shouldDismissAfterReset ? this.animateDismiss : undefined;\n    this.shouldDismissAfterReset = false;\n    this.initPositions({\n      isAnimating: false\n    }, runAfterSetState);\n  };\n  getDismissAnimationDirection = () => {\n    const {\n      allowDiagonalDismiss\n    } = this.props;\n    const {\n      swipeDirections,\n      swipeVelocities,\n      dragDirections,\n      dragDeltas\n    } = this.props.context;\n    const hasHorizontalSwipe = !_.isUndefined(swipeDirections.x);\n    const hasVerticalSwipe = !_.isUndefined(swipeDirections.y);\n    let isRight;\n    let isDown;\n\n    if (hasHorizontalSwipe || hasVerticalSwipe) {\n      if (!allowDiagonalDismiss && hasHorizontalSwipe && hasVerticalSwipe) {\n        // @ts-ignore\n        if (Math.abs(swipeVelocities.y) > Math.abs(swipeVelocities.x)) {\n          isDown = swipeDirections.y === PanningProvider.Directions.DOWN;\n        } else {\n          isRight = swipeDirections.x === PanningProvider.Directions.RIGHT;\n        }\n\n        return {\n          isRight,\n          isDown\n        };\n      }\n\n      if (hasHorizontalSwipe) {\n        isRight = swipeDirections.x === PanningProvider.Directions.RIGHT;\n      }\n\n      if (hasVerticalSwipe) {\n        isDown = swipeDirections.y === PanningProvider.Directions.DOWN;\n      }\n    } else {\n      // got here from a drag beyond threshold\n      const hasHorizontalDrag = !_.isUndefined(dragDirections.x);\n      const hasVerticalDrag = !_.isUndefined(dragDirections.y);\n\n      if (!allowDiagonalDismiss && hasHorizontalDrag && hasVerticalDrag) {\n        // @ts-ignore\n        if (Math.abs(dragDeltas.y) > Math.abs(dragDeltas.x)) {\n          isDown = dragDirections.y === PanningProvider.Directions.DOWN;\n        } else {\n          isRight = dragDirections.x === PanningProvider.Directions.RIGHT;\n        }\n\n        return {\n          isRight,\n          isDown\n        };\n      }\n\n      if (hasHorizontalDrag) {\n        isRight = dragDirections.x === PanningProvider.Directions.RIGHT;\n      }\n\n      if (hasVerticalDrag) {\n        isDown = dragDirections.y === PanningProvider.Directions.DOWN;\n      }\n    }\n\n    return {\n      isRight,\n      isDown\n    };\n  }; // Send undefined to not animate in the horizontal\\vertical direction\n  // isRight === true --> animate to the right\n  // isRight === false --> animate to the left\n  // isDown === true --> animate to the bottom\n  // isDown === false --> animate to the top\n\n  animateDismiss = () => {\n    const {\n      isAnimating\n    } = this.state;\n\n    if (isAnimating) {\n      this.shouldDismissAfterReset = true;\n    } else {\n      const {\n        directions = []\n      } = this.props;\n      const hasUp = directions.includes(PanningProvider.Directions.UP);\n      const hasRight = directions.includes(PanningProvider.Directions.RIGHT);\n      const hasLeft = directions.includes(PanningProvider.Directions.LEFT);\n      const hasDown = !hasUp && !hasLeft && !hasRight; // default\n\n      const verticalDismiss = hasDown ? true : hasUp ? false : undefined;\n      const horizontalDismiss = hasRight ? true : hasLeft ? false : undefined;\n\n      this._animateDismiss(horizontalDismiss, verticalDismiss);\n    }\n  };\n  _animateDismiss = (isRight, isDown) => {\n    const {\n      animationOptions\n    } = this.props;\n    const {\n      duration\n    } = animationOptions || DEFAULT_ANIMATION_OPTIONS;\n    const animations = [];\n    let toX;\n    let toY;\n\n    if (!_.isUndefined(isRight)) {\n      const maxSize = Constants.screenWidth + this.width;\n      toX = isRight ? maxSize : -maxSize;\n    }\n\n    if (!_.isUndefined(isDown)) {\n      const maxSize = Constants.screenHeight + this.height;\n      toY = isDown ? maxSize : -maxSize;\n    }\n\n    if (!_.isUndefined(toX)) {\n      animations.push(Animated.timing(this.animTranslateX, {\n        toValue: Math.round(toX),\n        useNativeDriver: true,\n        duration\n      }));\n    }\n\n    if (!_.isUndefined(toY)) {\n      animations.push(Animated.timing(this.animTranslateY, {\n        toValue: Math.round(toY),\n        useNativeDriver: true,\n        duration\n      }));\n    }\n\n    this.setState({\n      isAnimating: true\n    }, () => {\n      Animated.parallel(animations).start(this.onDismissAnimationFinished);\n    });\n  };\n  onDismissAnimationFinished = ({\n    finished\n  }) => {\n    if (finished) {\n      this.props.onDismiss?.();\n    }\n  };\n\n  render() {\n    const {\n      style\n    } = this.props;\n    const {\n      isAnimating\n    } = this.state;\n    const transform = isAnimating ? [{\n      translateX: this.animTranslateX\n    }, {\n      translateY: this.animTranslateY\n    }] : [];\n    return <Animated.View // @ts-ignore\n    ref={this.ref} style={[style, {\n      transform\n    }]} onLayout={this.onLayout}>\n        {this.props.children}\n      </Animated.View>;\n  }\n\n}\n\nexport default asPanViewConsumer(PanDismissibleView);"]},"metadata":{},"sourceType":"module"}